name: Registry Sync

on:
  schedule:
    - cron: '17 * * * *'
    - cron: '*/20 * * * *'
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

jobs:
  sync-registry:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Install jq and coreutils
        run: sudo apt-get update && sudo apt-get install -y jq coreutils openssl

      - name: Compute manifest hash
        id: manifest
        run: |
          MANIFEST=operators/chitty-cloud-repo-operator/config-manifest.json
          SHA=$(sha256sum "$MANIFEST" | awk '{print $1}')
          echo "sha=$SHA" >> $GITHUB_OUTPUT

      - name: Sign manifest with ChittyCert (preferred)
        if: env.CERT_SIGN_URL != ''
        env:
          CERT_SIGN_URL: ${{ secrets.CERT_SIGN_URL }}
          CERT_AUDIENCE: ${{ secrets.CERT_AUDIENCE }}
          CERT_TOKEN: ${{ secrets.CERT_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          # Obtain OIDC for ChittyCert audience if configured, else use CERT_TOKEN
          TOKEN="${CERT_TOKEN:-}"
          if [[ -z "$TOKEN" && -n "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" && -n "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" && -n "${CERT_AUDIENCE:-}" ]]; then
            TOKEN=$(curl -sS "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${CERT_AUDIENCE}" -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | jq -r '.value')
          fi
          DIGEST=$(printf "%s" "${{ steps.manifest.outputs.sha }}")
          payload=$(jq -n --arg alg "SHA256" --arg digest "$DIGEST" '{alg:$alg,digest:$digest}')
          code=$(curl -sS -o sign.json -w '%{http_code}' -X POST \
            -H "Authorization: Bearer ${TOKEN}" -H 'Content-Type: application/json' \
            --data "$payload" "$CERT_SIGN_URL")
          test "$code" = "200" || { echo "ChittyCert signing failed ($code)"; cat sign.json; exit 1; }
          jq -r '.signature' sign.json | tr -d '\n' > manifest.sig
          jq -r '.kid // empty' sign.json > manifest.kid || true

      - name: Sign manifest with OIDC identity
        if: env.CERT_SIGN_URL == ''
        shell: bash
        run: |
          set -euo pipefail
          # Create a detached signature using the OIDC request token as ephemeral keying material.
          # This is a lightweight binding for audit; replace with a proper KMS/HSM if desired.
          openssl dgst -sha256 -sign <(printf "%s" "${ACTIONS_ID_TOKEN_REQUEST_TOKEN}") \
            operators/chitty-cloud-repo-operator/config-manifest.json | base64 -w0 > manifest.sig

      - name: Get OIDC token for registry
        id: oidc_registry
        shell: bash
        run: |
          set -euo pipefail
          if [[ -n "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" && -n "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            TOKEN=$(curl -sS "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://registry.chitty.cc" \
              -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | jq -r '.value')
            if [[ "$TOKEN" == "null" || -z "$TOKEN" ]]; then
              echo "Failed to fetch OIDC token for registry" >&2; exit 1
            fi
            echo "token=$TOKEN" >> $GITHUB_OUTPUT
          else
            echo "token=${REGISTRY_TOKEN:-}" >> $GITHUB_OUTPUT
          fi
        env:
          REGISTRY_TOKEN: ${{ secrets.REGISTRY_TOKEN }}

      - name: Schema sync to registry (3x retry)
        env:
          TOKEN: ${{ steps.oidc_registry.outputs.token }}
          SHA: ${{ steps.manifest.outputs.sha }}
        run: |
          set -euo pipefail
          manifest_url="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/main/operators/chitty-cloud-repo-operator/config-manifest.json"
          payload=$(jq -n \
            --arg node "chitty-cloud-repo-operator" \
            --arg version "1.0.0" \
            --arg manifest_url "$manifest_url" \
            --arg commit_hash "$GITHUB_SHA" \
            --arg schema_hash "$SHA" \
            --arg timestamp "${{ github.event.head_commit.timestamp }}" \
            '{node:$node,version:$version,manifest_url:$manifest_url,commit_hash:$commit_hash,schema_hash:$schema_hash,timestamp:$timestamp}')
          for i in 1 2 3; do
            code=$(curl -sS -o resp.json -w '%{http_code}' -X POST \
              -H "Authorization: Bearer ${TOKEN}" \
              -H 'Content-Type: application/json' \
              --data "$payload" \
              https://registry.chitty.cc/v1/schema/sync || true)
            if [[ "$code" == "200" ]]; then
              echo "Schema sync ok"; jq -c '.status, .verified' resp.json; break
            fi
            echo "Schema sync failed (attempt $i, code $code)"; sleep $((2**i));
            if [[ $i -eq 3 ]]; then echo "Schema sync failed after retries" >&2; cat resp.json >&2; exit 1; fi
          done

      - name: Ledger OIDC token
        id: oidc_ledger
        shell: bash
        run: |
          set -euo pipefail
          if [[ -n "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" && -n "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            TOKEN=$(curl -sS "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=https://ledger.chitty.cc" \
              -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" | jq -r '.value')
            if [[ "$TOKEN" == "null" || -z "$TOKEN" ]]; then
              echo "Failed to fetch OIDC token for ledger" >&2; exit 1
            fi
            echo "token=$TOKEN" >> $GITHUB_OUTPUT
          else
            echo "token=${LEDGER_TOKEN:-}" >> $GITHUB_OUTPUT
          fi
        env:
          LEDGER_TOKEN: ${{ secrets.LEDGER_TOKEN }}

      - name: Ledger publish (3x retry)
        env:
          TOKEN: ${{ steps.oidc_ledger.outputs.token }}
          SHA: ${{ steps.manifest.outputs.sha }}
        run: |
          set -euo pipefail
          ts="${{ github.event.head_commit.timestamp }}"
          b="----BOUNDARY$RANDOM$RANDOM"
          mf="operators/chitty-cloud-repo-operator/config-manifest.json"
          # Signature produced in prior step; ensure exists
          sig="manifest.sig"; [[ -f "$sig" ]] || { echo "missing manifest.sig" >&2; exit 1; }
          body=$( \
            printf "--%s\r\nContent-Disposition: form-data; name=manifest; filename=manifest.json\r\nContent-Type: application/json\r\n\r\n" "$b"; cat "$mf"; \
            printf "\r\n--%s\r\nContent-Disposition: form-data; name=signature; filename=manifest.sig\r\nContent-Type: application/octet-stream\r\n\r\n" "$b"; cat "$sig"; \
            printf "\r\n--%s\r\nContent-Disposition: form-data; name=schema_hash\r\n\r\n%s\r\n" "$b" "$SHA"; \
            printf "--%s\r\nContent-Disposition: form-data; name=commit_ref\r\n\r\n%s\r\n" "$b" "$GITHUB_SHA"; \
            printf "--%s\r\nContent-Disposition: form-data; name=timestamp\r\n\r\n%s\r\n--%s--\r\n" "$b" "$ts" "$b" \
          )
          for i in 1 2 3; do
            code=$(curl -sS -o resp.json -w '%{http_code}' -X POST \
              -H "Authorization: Bearer ${TOKEN}" \
              -H "Content-Type: multipart/form-data; boundary=$b" \
              --data-binary @<(printf "%s" "$body") \
              https://ledger.chitty.cc/v1/records || true)
            if [[ "$code" == "201" ]]; then
              echo "Ledger publish ok"; jq -c '.status, .record_id' resp.json; break
            fi
            echo "Ledger publish failed (attempt $i, code $code)"; sleep $((2**i));
            if [[ $i -eq 3 ]]; then echo "Ledger publish failed after retries" >&2; cat resp.json >&2; exit 1; fi
          done

      - name: Verify signature via JWKS (optional)
        if: env.CERT_JWKS_URL != ''
        env:
          CERT_JWKS_URL: ${{ secrets.CERT_JWKS_URL }}
        run: |
          set -euo pipefail
          # Full verification using Node.js WebCrypto.
          # Requires: manifest (json), manifest.sig (base64), JWKS at CERT_JWKS_URL, optional manifest.kid
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');
          const { subtle } = require('crypto').webcrypto;

          function fetch(url){
            return new Promise((resolve,reject)=>{
              https.get(url,(res)=>{
                let data='';
                res.on('data',d=>data+=d);
                res.on('end',()=>{
                  if(res.statusCode>=200 && res.statusCode<300){ resolve({status:res.statusCode, body:data}); }
                  else reject(new Error(`HTTP ${res.statusCode}: ${data}`));
                });
              }).on('error',reject);
            });
          }

          (async () => {
            const manifest = fs.readFileSync('operators/chitty-cloud-repo-operator/config-manifest.json');
            const sigB64 = fs.readFileSync('manifest.sig','utf8').trim();
            const kid = fs.existsSync('manifest.kid') ? fs.readFileSync('manifest.kid','utf8').trim() : null;
            const jwksUrl = process.env.CERT_JWKS_URL;
            const jwks = JSON.parse((await fetch(jwksUrl)).body);
            if(!Array.isArray(jwks.keys) || jwks.keys.length===0) throw new Error('No keys in JWKS');
            const keys = kid ? jwks.keys.filter(k=>k.kid===kid) : jwks.keys;
            if(keys.length===0) throw new Error(`No JWKS key matches kid=${kid}`);

            const sig = Buffer.from(sigB64,'base64');
            let verified = false;
            let usedKid = null;
            for(const k of keys){
              try{
                let algo, keyData;
                if(k.kty === 'RSA'){
                  // Build SPKI from n,e
                  const n = Buffer.from(k.n, 'base64url');
                  const e = Buffer.from(k.e, 'base64url');
                  // Minimal ASN.1 builder for RSAPublicKey -> SPKI
                  function derLen(len){ if(len<128) return Buffer.from([len]);
                    const bytes=[]; let n=len; while(n>0){ bytes.unshift(n & 0xff); n >>=8; }
                    return Buffer.from([0x80|bytes.length, ...bytes]); }
                  function derInt(buf){ if(buf[0] & 0x80) buf = Buffer.concat([Buffer.from([0x00]), buf]);
                    return Buffer.concat([Buffer.from([0x02]), derLen(buf.length), buf]); }
                  const seq = (items) => { const body = Buffer.concat(items); return Buffer.concat([Buffer.from([0x30]), derLen(body.length), body]); };
                  const rsaPub = seq([ derInt(n), derInt(e) ]);
                  // SubjectPublicKeyInfo = SEQ( AlgorithmID rsaEncryption, BIT STRING RSAPublicKey )
                  const algId = Buffer.from('300d06092a864886f70d0101010500','hex');
                  const bitString = Buffer.concat([Buffer.from([0x03]), derLen(rsaPub.length+1), Buffer.from([0x00]), rsaPub]);
                  const spki = seq([ algId, bitString ]);
                  keyData = spki;
                  algo = { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' };
                } else if(k.kty === 'EC'){
                  // P-256 assumed; build SPKI from x,y
                  const x = Buffer.from(k.x, 'base64url');
                  const y = Buffer.from(k.y, 'base64url');
                  const pub = Buffer.concat([Buffer.from([0x04]), x, y]);
                  const algId = Buffer.from('301306072a8648ce3d020106082a8648ce3d030107','hex'); // id-ecPublicKey + prime256v1
                  function derLen(len){ if(len<128) return Buffer.from([len]); const bytes=[]; let n=len; while(n>0){ bytes.unshift(n&0xff); n>>=8;} return Buffer.from([0x80|bytes.length, ...bytes]); }
                  const seq=(items)=>{ const body=Buffer.concat(items); return Buffer.concat([Buffer.from([0x30]), derLen(body.length), body]); };
                  const bitString = Buffer.concat([Buffer.from([0x03]), derLen(pub.length+1), Buffer.from([0x00]), pub]);
                  const spki = seq([ algId, bitString ]);
                  keyData = spki;
                  algo = { name: 'ECDSA', hash: 'SHA-256' };
                } else {
                  continue;
                }
                const key = await subtle.importKey('spki', keyData, algo, false, ['verify']);
                const ok = await subtle.verify(algo, key, sig, manifest);
                if(ok){ verified = true; usedKid = k.kid || null; break; }
              }catch(e){ /* try next key */ }
            }
            if(!verified) throw new Error('Signature verification failed against provided JWKS');
            console.log('Signature verified', usedKid ? `(kid=${usedKid})` : '');
          })().catch((e)=>{ console.error(e.message||e); process.exit(1); });
          EOF

      - name: Health report (3x retry)
        env:
          TOKEN: ${{ steps.oidc_registry.outputs.token }}
        run: |
          set -euo pipefail
          payload=$(jq -n \
            --arg node "chitty-cloud-repo-operator" \
            --arg status "healthy" \
            --arg uptime "3600" \
            --arg schema_state "aligned" \
            --arg last_sync "${GITHUB_RUN_ID}" \
            --arg ledger_ref "ledger.chitty.cc/records/$(jq -r '.record_id // empty' resp.json 2>/dev/null || echo '')" \
            --arg timestamp "${{ github.event.head_commit.timestamp }}" \
            '{node:$node,status:$status,uptime:$uptime,schema_state:$schema_state,last_sync:$last_sync,ledger_ref:$ledger_ref,timestamp:$timestamp}')
          for i in 1 2 3; do
            code=$(curl -sS -o resp2.json -w '%{http_code}' -X POST \
              -H "Authorization: Bearer ${TOKEN}" \
              -H 'Content-Type: application/json' \
              --data "$payload" \
              https://registry.chitty.cc/v1/health/report || true)
            if [[ "$code" == "200" ]]; then
              echo "Health report ok"; jq -c '.status, .recorded' resp2.json; break
            fi
            echo "Health report failed (attempt $i, code $code)"; sleep $((2**i));
            if [[ $i -eq 3 ]]; then echo "Health report failed after retries" >&2; cat resp2.json >&2; exit 1; fi
          done

      - name: Report sync failure to PR
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            if (!context.issue?.number) {
              core.info('No PR context; skipping comment');
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `‚ùå Registry/Ledger sync failed in workflow run ${context.runId}. Check logs for details.`
              })
            }
